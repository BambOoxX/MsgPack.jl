<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Documentation · MsgPack</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MsgPack</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>API Documentation</a><ul class="internal"><li><a class="toctext" href="#Basic-Serialization/Deserialization-1">Basic Serialization/Deserialization</a></li><li><a class="toctext" href="#Julia-–-MessagePack-Conversion-1">Julia &lt;–&gt; MessagePack Conversion</a></li><li><a class="toctext" href="#Julia-–-MessagePack-Interface-Types-1">Julia &lt;–&gt; MessagePack Interface Types</a></li><li><a class="toctext" href="#View-Types-1">View Types</a></li><li><a class="toctext" href="#MessagePack-Extension-Functionality-1">MessagePack Extension Functionality</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API Documentation</a></li></ul><a class="edit-page" href="https://github.com/JuliaIO/MsgPack.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API Documentation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-Documentation-1" href="#API-Documentation-1">API Documentation</a></h1><p>Below is the documentation for all MsgPack API functions. For information on MsgPack, please see <a href="https://github.com/JuliaIO/MsgPack.jl">the package&#39;s README</a>.</p><h2><a class="nav-anchor" id="Basic-Serialization/Deserialization-1" href="#Basic-Serialization/Deserialization-1">Basic Serialization/Deserialization</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.unpack" href="#MsgPack.unpack"><code>MsgPack.unpack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">unpack(bytes, T::Type = Any)</code></pre><p>Return <code>unpack(IOBuffer(bytes), T)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/unpack.jl#L3-L7">source</a><div><div><pre><code class="language-none">unpack(msgpack_byte_stream::IO, T::Type = Any)</code></pre><p>Return the Julia value of type <code>T</code> deserialized from <code>msgpack_byte_stream</code>.</p><p><code>T</code> is assumed to have valid <a href="#MsgPack.msgpack_type"><code>msgpack_type</code></a> and <a href="#MsgPack.from_msgpack"><code>from_msgpack</code></a> definitions.</p><p>If <code>msgpack_type(T) === AnyType()</code>, <code>unpack</code> will deserialize the next MessagePack object from <code>msgpack_byte_stream</code> into the default Julia representation corresponding to the object&#39;s MessagePack type. For details on default Julia representations, see <a href="#MsgPack.AbstractMsgPackType"><code>AbstractMsgPackType</code></a>.</p><p>See also: <a href="#MsgPack.pack"><code>pack</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/unpack.jl#L10-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.pack" href="#MsgPack.pack"><code>MsgPack.pack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pack(x)</code></pre><p>Serialize <code>x</code> to MessagePack format and return the resulting <code>Vector{UInt8}</code>.</p><p>This function uses <a href="#MsgPack.msgpack_type"><code>msgpack_type</code></a> and <a href="#MsgPack.to_msgpack"><code>to_msgpack</code></a> to determine the appropriate translation of the <code>value</code> into MessagePack format.</p><p>See also: <a href="#MsgPack.unpack"><code>unpack</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/pack.jl#L1-L10">source</a><div><div><pre><code class="language-none">pack(io::IO, x)</code></pre><p>Like <code>pack(x)</code>, but write the resulting bytes to <code>io</code>. Returns <code>nothing</code>.</p><p>See also: <a href="#MsgPack.unpack"><code>unpack</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/pack.jl#L17-L23">source</a></section><h2><a class="nav-anchor" id="Julia-–-MessagePack-Conversion-1" href="#Julia-–-MessagePack-Conversion-1">Julia &lt;–&gt; MessagePack Conversion</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.msgpack_type" href="#MsgPack.msgpack_type"><code>MsgPack.msgpack_type</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">msgpack_type(::Type{T}) where {T}</code></pre><p>Return an instance of the <a href="#MsgPack.AbstractMsgPackType"><code>AbstractMsgPackType</code></a> subtype corresponding to <code>T</code>&#39;s intended MessagePack representation. For example:</p><pre><code class="language-none">msgpack_type(::Type{UUID}) = StringType()</code></pre><p>If this method is overloaded such that <code>msgpack_type(T) === M()</code>, then <code>to_msgpack(::M, ::T)</code> and <code>from_msgpack(::Type{T}, x)</code> should also be overloaded to handle conversion of <code>T</code> instances to/from MsgPack-compatible types.</p><p>By default, this method returns <code>AnyType()</code>. While this fallback method need not be overloaded to support deserialization of <code>T</code> instances via <code>unpack</code>, <code>msgpack_type(T)</code> must be overloaded to return a non-<code>AnyType</code> <code>AbstractMsgPackType</code> instance in order to support serializing <code>T</code> instances via <code>pack</code>.</p><p>See also: <a href="#MsgPack.from_msgpack"><code>from_msgpack</code></a>, <a href="#MsgPack.to_msgpack"><code>to_msgpack</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/types.jl#L210-L230">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.to_msgpack" href="#MsgPack.to_msgpack"><code>MsgPack.to_msgpack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">to_msgpack(::M, value_to_serialize::T) where {M&lt;:AbstractMsgPackType,T}</code></pre><p>Return an &quot;<code>M</code>-compatible&quot; representation of <code>value_to_serialize</code> (for compatibility definitions, see the docstrings for subtypes of <a href="#MsgPack.AbstractMsgPackType"><code>AbstractMsgPackType</code></a>).</p><p>By default, <code>to_msgpack</code> simply returns <code>value_to_serialize</code> directly.</p><p>The implementation of <a href="#MsgPack.pack"><code>pack</code></a> utilizes this function for every value encountered during serialization, calling it in a manner similar to the following psuedocode:</p><pre><code class="language-none">t = msgpack_type(T)
value_in_compatible_representation = to_msgpack(t, value_to_serialize::T)
_serialize_in_msgpack_format(t, value_in_compatible_representation)</code></pre><p>For example, if <code>msgpack_type(UUID)</code> was defined to return <code>StringType()</code>, an appropriate <code>to_msgpack</code> implementation might be:</p><pre><code class="language-none">to_msgpack(::StringType, uuid::UUID) = string(uuid)</code></pre><p>See also: <a href="#MsgPack.from_msgpack"><code>from_msgpack</code></a>, <a href="#MsgPack.msgpack_type"><code>msgpack_type</code></a>, <a href="#MsgPack.AbstractMsgPackType"><code>AbstractMsgPackType</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/types.jl#L233-L259">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.from_msgpack" href="#MsgPack.from_msgpack"><code>MsgPack.from_msgpack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">from_msgpack(::Type{T}, value_deserialized_by_msgpack) where {T}</code></pre><p>Return the <code>value_deserialized_by_msgpack</code> converted to type <code>T</code>. By default, this method simply calls <code>convert(T, value_deserialized_by_msgpack)</code>.</p><p>The implementation of <a href="#MsgPack.unpack"><code>unpack</code></a> calls this function on every deserialized value; in this case, <code>T</code> is generally derived from the type specified by the caller of <code>unpack</code>.</p><p>For example, if <code>msgpack_type(UUID)</code> was defined to return <code>StringType()</code>, an appropriate <code>from_msgpack</code> implementation might be:</p><pre><code class="language-none">from_msgpack(::Type{UUID}, uuid::AbstractString) = UUID(uuid)</code></pre><p>See also: <a href="#MsgPack.to_msgpack"><code>to_msgpack</code></a>, <a href="#MsgPack.msgpack_type"><code>msgpack_type</code></a>, <a href="#MsgPack.AbstractMsgPackType"><code>AbstractMsgPackType</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/types.jl#L262-L280">source</a></section><h2><a class="nav-anchor" id="Julia-–-MessagePack-Interface-Types-1" href="#Julia-–-MessagePack-Interface-Types-1">Julia &lt;–&gt; MessagePack Interface Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.AbstractMsgPackType" href="#MsgPack.AbstractMsgPackType"><code>MsgPack.AbstractMsgPackType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractMsgPackType</code></pre><p>An abstract type whose subtypes define a MessagePack &lt;–&gt; Julia type interface.</p><p>The subtypes of <code>AbstractMsgPackType</code> are:</p><ul><li><a href="#MsgPack.IntegerType"><code>IntegerType</code></a></li><li><a href="#MsgPack.NilType"><code>NilType</code></a></li><li><a href="#MsgPack.BooleanType"><code>BooleanType</code></a></li><li><a href="#MsgPack.FloatType"><code>FloatType</code></a></li><li><a href="#MsgPack.StringType"><code>StringType</code></a></li><li><a href="#MsgPack.BinaryType"><code>BinaryType</code></a></li><li><a href="#MsgPack.ArrayType"><code>ArrayType</code></a></li><li><a href="#MsgPack.MapType"><code>MapType</code></a></li><li><a href="#MsgPack.ExtensionType"><code>ExtensionType</code></a></li><li><a href="#MsgPack.AnyType"><code>AnyType</code></a></li><li><a href="#MsgPack.ImmutableStructType"><code>ImmutableStructType</code></a></li><li><a href="#MsgPack.MutableStructType"><code>MutableStructType</code></a></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/types.jl#L5-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.IntegerType" href="#MsgPack.IntegerType"><code>MsgPack.IntegerType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IntegerType &lt;: AbstractMsgPackType</code></pre><p>A Julia type corresponding to the MessagePack Integer type.</p><p>If <code>msgpack_type(T)</code> is defined to return <code>IntegerType()</code>, then <code>T</code> must support:</p><ul><li><code>to_msgpack(::IntegerType, ::T)::S</code></li><li><code>from_msgpack(::Type{T}, ::S)::T</code></li><li>standard numeric comparators (<code>&gt;</code>, <code>&lt;</code>, <code>==</code>, etc.) against values of type <code>S</code></li></ul><p>where <code>S</code> may be one of the following types:</p><ul><li><code>UInt8</code></li><li><code>UInt16</code></li><li><code>UInt32</code></li><li><code>UInt64</code></li><li><code>Int8</code></li><li><code>Int16</code></li><li><code>Int32</code></li><li><code>Int64</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/types.jl#L27-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.NilType" href="#MsgPack.NilType"><code>MsgPack.NilType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NilType &lt;: AbstractMsgPackType</code></pre><p>A Julia type corresponding to the MessagePack Nil type.</p><p>If <code>msgpack_type(T)</code> is defined to return <code>NilType()</code>, then <code>T</code> must support:</p><ul><li><code>from_msgpack(::Type{T}, ::Nothing)::T</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/types.jl#L51-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.BooleanType" href="#MsgPack.BooleanType"><code>MsgPack.BooleanType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BooleanType &lt;: AbstractMsgPackType</code></pre><p>A Julia type corresponding to the MessagePack Boolean type.</p><p>If <code>msgpack_type(T)</code> is defined to return <code>BooleanType()</code>, then <code>T</code> must support:</p><ul><li><code>to_msgpack(::BooleanType, ::T)::Bool</code></li><li><code>from_msgpack(::Type{T}, ::Bool)::T</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/types.jl#L62-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.FloatType" href="#MsgPack.FloatType"><code>MsgPack.FloatType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FloatType &lt;: AbstractMsgPackType</code></pre><p>A Julia type corresponding to the MessagePack Float type.</p><p>If <code>msgpack_type(T)</code> is defined to return <code>FloatType()</code>, then <code>T</code> must support:</p><ul><li><code>to_msgpack(::FloatType, ::T)::S</code></li><li><code>from_msgpack(::Type{T}, ::S)::T</code></li><li>standard numeric comparators (<code>&gt;</code>, <code>&lt;</code>, <code>==</code>, etc.) against values of type <code>S</code></li></ul><p>where <code>S</code> may be one of the following types:</p><ul><li><code>Float32</code></li><li><code>Float64</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/types.jl#L74-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.StringType" href="#MsgPack.StringType"><code>MsgPack.StringType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">StringType &lt;: AbstractMsgPackType</code></pre><p>A Julia type corresponding to the MessagePack String type.</p><p>If <code>msgpack_type(T)</code> is defined to return <code>StringType()</code>, then <code>T</code> must support:</p><ul><li><code>to_msgpack(::StringType, ::T)::String</code></li><li><code>from_msgpack(::Type{T}, ::String)::T</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/types.jl#L92-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.BinaryType" href="#MsgPack.BinaryType"><code>MsgPack.BinaryType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BinaryType &lt;: AbstractMsgPackType</code></pre><p>A Julia type corresponding to the MessagePack Binary type.</p><p>If <code>msgpack_type(T)</code> is defined to return <code>BinaryType()</code>, then <code>T</code> must support:</p><ul><li><code>to_msgpack(::BinaryType, ::T)::Vector{UInt8}</code></li><li><code>from_msgpack(::Type{T}, ::Vector{UInt8})::T</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/types.jl#L104-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.ArrayType" href="#MsgPack.ArrayType"><code>MsgPack.ArrayType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ArrayType &lt;: AbstractMsgPackType</code></pre><p>A Julia type corresponding to the MessagePack Array type.</p><p>If <code>msgpack_type(T)</code> is defined to return <code>ArrayType()</code>, then <code>T</code> must support the Julia <code>AbstractArray</code> interface, and/or must support:</p><ul><li><code>to_msgpack(::ArrayType, ::T)::AbstractArray</code></li><li><code>from_msgpack(::Type{T}, ::Vector)::T</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/types.jl#L116-L126">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.MapType" href="#MsgPack.MapType"><code>MsgPack.MapType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MapType &lt;: AbstractMsgPackType</code></pre><p>A Julia type corresponding to the MessagePack Map type.</p><p>If <code>msgpack_type(T)</code> is defined to return <code>MapType()</code>, then <code>T</code> must support the Julia <code>AbstractDict</code> interface, and/or must support:</p><ul><li><code>to_msgpack(::ArrayType, ::T)::AbstractDict</code></li><li><code>from_msgpack(::Type{T}, ::Dict)::T</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/types.jl#L129-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.ExtensionType" href="#MsgPack.ExtensionType"><code>MsgPack.ExtensionType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ExtensionType &lt;: AbstractMsgPackType</code></pre><p>A Julia type corresponding to the MessagePack Extension type.</p><p>If <code>msgpack_type(T)</code> is defined to return <code>ExtensionType()</code>, then <code>T</code> must support:</p><ul><li><code>to_msgpack(::ExtensionType, ::T)::Extension</code></li><li><code>from_msgpack(::Type{T}, ::Extension)::T</code></li></ul><p>See also: <a href="#MsgPack.Extension"><code>Extension</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/types.jl#L142-L153">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.AnyType" href="#MsgPack.AnyType"><code>MsgPack.AnyType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AnyType &lt;: AbstractMsgPackType</code></pre><p>The fallback return type of <code>msgpack_type(::Type)</code>, indicating that the given Julia type does not have a known corresponding MessagePack type.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/types.jl#L156-L161">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.ImmutableStructType" href="#MsgPack.ImmutableStructType"><code>MsgPack.ImmutableStructType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ImmutableStructType &lt;: AbstractMsgPackType</code></pre><p>If <code>msgpack_type(T)</code> is defined to return <code>ImmutableStructType</code>, <code>T</code> will be (de)serialized as a MessagePack Map type assuming certain constraints that enable additional optimizations:</p><ul><li><code>T</code> supports <code>fieldcount</code>, <code>fieldtype</code>, <code>fieldname</code>, <code>getfield</code>, and a constructor</li></ul><p>that can be called as <code>T((getfield(x::T, i) for i in 1:fieldcount(T))...)</code> for any <code>T</code> instance <code>x</code>.</p><ul><li><a href="#MsgPack.unpack"><code>unpack</code></a> will assume that incoming bytes to be deserialized to <code>T</code></li></ul><p>will always be formmatted as a MessagePack Map whose fields correspond exactly to the fields of <code>T</code>. In other words, the <code>i</code>th key in the Map must correspond to <code>fieldname(T, i)</code>, and the <code>i</code>th value must correspond to <code>getfield(::T, i)</code>.</p><p>This type is similar to <a href="#MsgPack.MutableStructType"><code>MutableStructType</code></a>, but generally achieves greater (de)serialization performance by imposing tighter constraints.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/types.jl#L164-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.MutableStructType" href="#MsgPack.MutableStructType"><code>MsgPack.MutableStructType</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MutableStructType &lt;: AbstractMsgPackType</code></pre><p>If <code>msgpack_type(T)</code> is defined to return <code>MutableStructType</code>, <code>T</code> will be (de)serialized as a MessagePack Map type assuming certain constraints that enable additional optimizations:</p><ul><li><code>T</code> supports <code>fieldcount</code>, <code>fieldtype</code>, <code>fieldname</code>, <code>getfield</code>, <code>setfield!</code>,</li></ul><p>and has the inner constructor <code>T() = new()</code>.</p><ul><li><a href="#MsgPack.unpack"><code>unpack</code></a> will assume that incoming bytes to be deserialized to <code>T</code></li></ul><p>will always be formmatted as a MessagePack Map whose fields are an unordered subset of the fields of <code>T</code>. If a given field is not present in the MessagePack Map, the corresponding field of the returned <code>T</code> instance will be left uninitialized.</p><p>This type is similar to <a href="#MsgPack.ImmutableStructType"><code>ImmutableStructType</code></a>, but imposes fewer constraints at the cost of (de)serialization performance.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/types.jl#L185-L203">source</a></section><h2><a class="nav-anchor" id="View-Types-1" href="#View-Types-1">View Types</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.ArrayView" href="#MsgPack.ArrayView"><code>MsgPack.ArrayView</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ArrayView{T} &lt;: AbstractVector{T}</code></pre><p>A Julia struct that wraps a MessagePack byte buffer to provide an immutable view of the MessagePack Array stored within the wrapped byte buffer.</p><p>This type is intended to be utilized via <a href="#MsgPack.unpack"><code>unpack</code></a>. For example, a call to <code>arr = unpack(bytes, ArrayView{Dict{String,Int32}})</code> will generally return a value more quickly than <code>arr = unpack(bytes, Vector{Dict{String,Int32}})</code>; the latter will perform full deserialization immediately while the former will only scan over <code>bytes</code> to tag the positions of <code>arr</code>&#39;s elements, deferring the actual deserialization of these elements to the time of their access via <code>arr[index]</code>.</p><p>Note that <code>ArrayView</code> does not implement any form of caching - repeat accesses of the same element will re-deserialize the element upon every access.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/views.jl#L5-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.MapView" href="#MsgPack.MapView"><code>MsgPack.MapView</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MapView{K,V} &lt;: AbstractDict{K,V}</code></pre><p>Similar to <a href="#MsgPack.ArrayView"><code>ArrayView</code></a>, but provides an immutable view to a MessagePack Map rather than a MessagePack Array.</p><p>This type is intended to be utilized via <a href="#MsgPack.unpack"><code>unpack</code></a> in the same manner as <code>ArrayView</code>, and is similarly implements a &quot;delay-deserialization-until-access&quot; mechanism.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/views.jl#L44-L53">source</a></section><h2><a class="nav-anchor" id="MessagePack-Extension-Functionality-1" href="#MessagePack-Extension-Functionality-1">MessagePack Extension Functionality</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.Extension" href="#MsgPack.Extension"><code>MsgPack.Extension</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Extension
    type::Int8
    data::Vector{UInt8}
end</code></pre><p>A wrapper for bytes formatted to the MessagePack Extension type specification.</p><p>See also: <a href="#MsgPack.extserialize"><code>extserialize</code></a>, <a href="#MsgPack.extdeserialize"><code>extdeserialize</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/types.jl#L350-L359">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.extserialize" href="#MsgPack.extserialize"><code>MsgPack.extserialize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">extserialize(type, x)</code></pre><p>Return <code>Extension(type, data)</code> where <code>data</code> is the result of calling Julia&#39;s built-in <code>serialize</code> function on <code>x</code>, facilitating direct serialization Julia values to MessagePack format:</p><pre><code class="language-none">julia&gt; struct Point{T}
           x::T
           y::T
       end

julia&gt; val = [Point(rand(), rand()) for _ in 1:100];

julia&gt; bytes = MsgPack.pack(MsgPack.extserialize(123, x));

julia&gt; type, new_val = MsgPack.extdeserialize(MsgPack.unpack(bytes));

julia&gt; type == 123
true

julia&gt; new_val == val
true</code></pre><p>Note that <code>extserialize</code>/<a href="#MsgPack.extdeserialize"><code>extdeserialize</code></a> are subject to the same caveat as Julia&#39;s built-in <code>serialize</code>/<code>deserialize</code> functions: &quot;In general, this process will not work if the reading and writing are done by different versions of Julia, or an instance of Julia with a different system image.&quot;.</p><p>See also: <a href="#MsgPack.Extension"><code>Extension</code></a>, <a href="#MsgPack.extdeserialize"><code>extdeserialize</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/types.jl#L371-L403">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MsgPack.extdeserialize" href="#MsgPack.extdeserialize"><code>MsgPack.extdeserialize</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">extdeserialize(x::Extension)</code></pre><p>Return <code>(x.type, value)</code> where <code>value</code> is the result of calling Julia&#39;s built-in <code>deserialize</code> function on <code>x.data</code>.</p><p>This function is meant to be used in conjuction with <a href="#MsgPack.extserialize"><code>extserialize</code></a>; see that function&#39;s docstring for more details.</p><p>See also: <a href="#MsgPack.Extension"><code>Extension</code></a>, <a href="#MsgPack.extserialize"><code>extserialize</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaIO/MsgPack.jl/blob/03a09c5756870be3fad2eae2fa3bd5ae394182c2/src/types.jl#L410-L420">source</a></section><footer><hr/></footer></article></body></html>
