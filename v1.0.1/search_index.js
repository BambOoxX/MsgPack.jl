var documenterSearchIndex = {"docs":
[{"location":"#API-Documentation-1","page":"API Documentation","title":"API Documentation","text":"","category":"section"},{"location":"#","page":"API Documentation","title":"API Documentation","text":"Below is the documentation for all MsgPack API functions. For information on MsgPack, please see the package's README.","category":"page"},{"location":"#","page":"API Documentation","title":"API Documentation","text":"CurrentModule = MsgPack","category":"page"},{"location":"#Basic-Serialization/Deserialization-1","page":"API Documentation","title":"Basic Serialization/Deserialization","text":"","category":"section"},{"location":"#","page":"API Documentation","title":"API Documentation","text":"unpack\npack","category":"page"},{"location":"#MsgPack.unpack","page":"API Documentation","title":"MsgPack.unpack","text":"unpack(bytes, T::Type = Any)\n\nReturn unpack(IOBuffer(bytes), T).\n\n\n\n\n\nunpack(msgpack_byte_stream::IO, T::Type = Any)\n\nReturn the Julia value of type T deserialized from msgpack_byte_stream.\n\nT is assumed to have valid msgpack_type and from_msgpack definitions.\n\nIf msgpack_type(T) === AnyType(), unpack will deserialize the next MessagePack object from msgpack_byte_stream into the default Julia representation corresponding to the object's MessagePack type. For details on default Julia representations, see AbstractMsgPackType.\n\nSee also: pack\n\n\n\n\n\n","category":"function"},{"location":"#MsgPack.pack","page":"API Documentation","title":"MsgPack.pack","text":"pack(x)\n\nSerialize x to MessagePack format and return the resulting Vector{UInt8}.\n\nThis function uses msgpack_type and to_msgpack to determine the appropriate translation of the value into MessagePack format.\n\nSee also: unpack\n\n\n\n\n\npack(io::IO, x)\n\nLike pack(x), but write the resulting bytes to io. Returns nothing.\n\nSee also: unpack\n\n\n\n\n\n","category":"function"},{"location":"#Julia-–-MessagePack-Conversion-1","page":"API Documentation","title":"Julia <–> MessagePack Conversion","text":"","category":"section"},{"location":"#","page":"API Documentation","title":"API Documentation","text":"MsgPack.msgpack_type\nMsgPack.to_msgpack\nMsgPack.from_msgpack","category":"page"},{"location":"#MsgPack.msgpack_type","page":"API Documentation","title":"MsgPack.msgpack_type","text":"msgpack_type(::Type{T}) where {T}\n\nReturn an instance of the AbstractMsgPackType subtype corresponding to T's intended MessagePack representation. For example:\n\nmsgpack_type(::Type{UUID}) = StringType()\n\nIf this method is overloaded such that msgpack_type(T) === M(), then to_msgpack(::M, ::T) and from_msgpack(::Type{T}, x) should also be overloaded to handle conversion of T instances to/from MsgPack-compatible types.\n\nBy default, this method returns AnyType(). While this fallback method need not be overloaded to support deserialization of T instances via unpack, msgpack_type(T) must be overloaded to return a non-AnyType AbstractMsgPackType instance in order to support serializing T instances via pack.\n\nSee also: from_msgpack, to_msgpack\n\n\n\n\n\n","category":"function"},{"location":"#MsgPack.to_msgpack","page":"API Documentation","title":"MsgPack.to_msgpack","text":"to_msgpack(::M, value_to_serialize::T) where {M<:AbstractMsgPackType,T}\n\nReturn an \"M-compatible\" representation of value_to_serialize (for compatibility definitions, see the docstrings for subtypes of AbstractMsgPackType).\n\nBy default, to_msgpack simply returns value_to_serialize directly.\n\nThe implementation of pack utilizes this function for every value encountered during serialization, calling it in a manner similar to the following psuedocode:\n\nt = msgpack_type(T)\nvalue_in_compatible_representation = to_msgpack(t, value_to_serialize::T)\n_serialize_in_msgpack_format(t, value_in_compatible_representation)\n\nFor example, if msgpack_type(UUID) was defined to return StringType(), an appropriate to_msgpack implementation might be:\n\nto_msgpack(::StringType, uuid::UUID) = string(uuid)\n\nSee also: from_msgpack, msgpack_type, AbstractMsgPackType\n\n\n\n\n\n","category":"function"},{"location":"#MsgPack.from_msgpack","page":"API Documentation","title":"MsgPack.from_msgpack","text":"from_msgpack(::Type{T}, value_deserialized_by_msgpack) where {T}\n\nReturn the value_deserialized_by_msgpack converted to type T. By default, this method simply calls convert(T, value_deserialized_by_msgpack).\n\nThe implementation of unpack calls this function on every deserialized value; in this case, T is generally derived from the type specified by the caller of unpack.\n\nFor example, if msgpack_type(UUID) was defined to return StringType(), an appropriate from_msgpack implementation might be:\n\nfrom_msgpack(::Type{UUID}, uuid::AbstractString) = UUID(uuid)\n\nSee also: to_msgpack, msgpack_type, AbstractMsgPackType\n\n\n\n\n\n","category":"function"},{"location":"#Julia-–-MessagePack-Interface-Types-1","page":"API Documentation","title":"Julia <–> MessagePack Interface Types","text":"","category":"section"},{"location":"#","page":"API Documentation","title":"API Documentation","text":"AbstractMsgPackType\nIntegerType\nNilType\nBooleanType\nFloatType\nStringType\nBinaryType\nArrayType\nMapType\nExtensionType\nAnyType\nImmutableStructType\nMutableStructType","category":"page"},{"location":"#MsgPack.AbstractMsgPackType","page":"API Documentation","title":"MsgPack.AbstractMsgPackType","text":"AbstractMsgPackType\n\nAn abstract type whose subtypes define a MessagePack <–> Julia type interface.\n\nThe subtypes of AbstractMsgPackType are:\n\nIntegerType\nNilType\nBooleanType\nFloatType\nStringType\nBinaryType\nArrayType\nMapType\nExtensionType\nAnyType\nImmutableStructType\nMutableStructType\n\n\n\n\n\n","category":"type"},{"location":"#MsgPack.IntegerType","page":"API Documentation","title":"MsgPack.IntegerType","text":"IntegerType <: AbstractMsgPackType\n\nA Julia type corresponding to the MessagePack Integer type.\n\nIf msgpack_type(T) is defined to return IntegerType(), then T must support:\n\nto_msgpack(::IntegerType, ::T)::S\nfrom_msgpack(::Type{T}, ::S)::T\nstandard numeric comparators (>, <, ==, etc.) against values of type S\n\nwhere S may be one of the following types:\n\nUInt8\nUInt16\nUInt32\nUInt64\nInt8\nInt16\nInt32\nInt64\n\n\n\n\n\n","category":"type"},{"location":"#MsgPack.NilType","page":"API Documentation","title":"MsgPack.NilType","text":"NilType <: AbstractMsgPackType\n\nA Julia type corresponding to the MessagePack Nil type.\n\nIf msgpack_type(T) is defined to return NilType(), then T must support:\n\nfrom_msgpack(::Type{T}, ::Nothing)::T\n\n\n\n\n\n","category":"type"},{"location":"#MsgPack.BooleanType","page":"API Documentation","title":"MsgPack.BooleanType","text":"BooleanType <: AbstractMsgPackType\n\nA Julia type corresponding to the MessagePack Boolean type.\n\nIf msgpack_type(T) is defined to return BooleanType(), then T must support:\n\nto_msgpack(::BooleanType, ::T)::Bool\nfrom_msgpack(::Type{T}, ::Bool)::T\n\n\n\n\n\n","category":"type"},{"location":"#MsgPack.FloatType","page":"API Documentation","title":"MsgPack.FloatType","text":"FloatType <: AbstractMsgPackType\n\nA Julia type corresponding to the MessagePack Float type.\n\nIf msgpack_type(T) is defined to return FloatType(), then T must support:\n\nto_msgpack(::FloatType, ::T)::S\nfrom_msgpack(::Type{T}, ::S)::T\nstandard numeric comparators (>, <, ==, etc.) against values of type S\n\nwhere S may be one of the following types:\n\nFloat32\nFloat64\n\n\n\n\n\n","category":"type"},{"location":"#MsgPack.StringType","page":"API Documentation","title":"MsgPack.StringType","text":"StringType <: AbstractMsgPackType\n\nA Julia type corresponding to the MessagePack String type.\n\nIf msgpack_type(T) is defined to return StringType(), then T must support:\n\nto_msgpack(::StringType, ::T)::String\nfrom_msgpack(::Type{T}, ::String)::T\n\n\n\n\n\n","category":"type"},{"location":"#MsgPack.BinaryType","page":"API Documentation","title":"MsgPack.BinaryType","text":"BinaryType <: AbstractMsgPackType\n\nA Julia type corresponding to the MessagePack Binary type.\n\nIf msgpack_type(T) is defined to return BinaryType(), then T must support:\n\nto_msgpack(::BinaryType, ::T)::Vector{UInt8}\nfrom_msgpack(::Type{T}, ::Vector{UInt8})::T\n\n\n\n\n\n","category":"type"},{"location":"#MsgPack.ArrayType","page":"API Documentation","title":"MsgPack.ArrayType","text":"ArrayType <: AbstractMsgPackType\n\nA Julia type corresponding to the MessagePack Array type.\n\nIf msgpack_type(T) is defined to return ArrayType(), then T must support:\n\nlength\niterate\nMsgPack._eltype(T) (falls back to eltype(T))\n\nand/or must support:\n\nto_msgpack(::ArrayType, ::T)::AbstractArray\nfrom_msgpack(::Type{T}, ::Vector)::T\n\n\n\n\n\n","category":"type"},{"location":"#MsgPack.MapType","page":"API Documentation","title":"MsgPack.MapType","text":"MapType <: AbstractMsgPackType\n\nA Julia type corresponding to the MessagePack Map type.\n\nIf msgpack_type(T) is defined to return MapType(), then T must support:\n\nlength\niterate\nMsgPack._keytype(T) (falls back to keytype(T))\nMsgPack._valtype(T) (falls back to valtype(T))\n\nand/or must support:\n\nto_msgpack(::ArrayType, ::T)::AbstractDict\nfrom_msgpack(::Type{T}, ::Dict)::T\n\n\n\n\n\n","category":"type"},{"location":"#MsgPack.ExtensionType","page":"API Documentation","title":"MsgPack.ExtensionType","text":"ExtensionType <: AbstractMsgPackType\n\nA Julia type corresponding to the MessagePack Extension type.\n\nIf msgpack_type(T) is defined to return ExtensionType(), then T must support:\n\nto_msgpack(::ExtensionType, ::T)::Extension\nfrom_msgpack(::Type{T}, ::Extension)::T\n\nSee also: Extension\n\n\n\n\n\n","category":"type"},{"location":"#MsgPack.AnyType","page":"API Documentation","title":"MsgPack.AnyType","text":"AnyType <: AbstractMsgPackType\n\nThe fallback return type of msgpack_type(::Type), indicating that the given Julia type does not have a known corresponding MessagePack type.\n\n\n\n\n\n","category":"type"},{"location":"#MsgPack.ImmutableStructType","page":"API Documentation","title":"MsgPack.ImmutableStructType","text":"ImmutableStructType <: AbstractMsgPackType\n\nIf msgpack_type(T) is defined to return ImmutableStructType, T will be (de)serialized as a MessagePack Map type assuming certain constraints that enable additional optimizations:\n\nT supports fieldcount, fieldtype, fieldname, getfield, and a constructor\n\nthat can be called as T((getfield(x::T, i) for i in 1:fieldcount(T))...) for any T instance x.\n\nunpack will assume that incoming bytes to be deserialized to T\n\nwill always be formmatted as a MessagePack Map whose fields correspond exactly to the fields of T. In other words, the ith key in the Map must correspond to fieldname(T, i), and the ith value must correspond to getfield(::T, i).\n\nThis type is similar to MutableStructType, but generally achieves greater (de)serialization performance by imposing tighter constraints.\n\n\n\n\n\n","category":"type"},{"location":"#MsgPack.MutableStructType","page":"API Documentation","title":"MsgPack.MutableStructType","text":"MutableStructType <: AbstractMsgPackType\n\nIf msgpack_type(T) is defined to return MutableStructType, T will be (de)serialized as a MessagePack Map type assuming certain constraints that enable additional optimizations:\n\nT supports fieldcount, fieldtype, fieldname, getfield, setfield!,\n\nand has the inner constructor T() = new().\n\nunpack will assume that incoming bytes to be deserialized to T\n\nwill always be formmatted as a MessagePack Map whose fields are an unordered subset of the fields of T. If a given field is not present in the MessagePack Map, the corresponding field of the returned T instance will be left uninitialized.\n\nThis type is similar to ImmutableStructType, but imposes fewer constraints at the cost of (de)serialization performance.\n\n\n\n\n\n","category":"type"},{"location":"#View-Types-1","page":"API Documentation","title":"View Types","text":"","category":"section"},{"location":"#","page":"API Documentation","title":"API Documentation","text":"MsgPack.ArrayView\nMsgPack.MapView","category":"page"},{"location":"#MsgPack.ArrayView","page":"API Documentation","title":"MsgPack.ArrayView","text":"ArrayView{T} <: AbstractVector{T}\n\nA Julia struct that wraps a MessagePack byte buffer to provide an immutable view of the MessagePack Array stored within the wrapped byte buffer.\n\nThis type is intended to be utilized via unpack. For example, a call to arr = unpack(bytes, ArrayView{Dict{String,Int32}}) will generally return a value more quickly than arr = unpack(bytes, Vector{Dict{String,Int32}}); the latter will perform full deserialization immediately while the former will only scan over bytes to tag the positions of arr's elements, deferring the actual deserialization of these elements to the time of their access via arr[index].\n\nNote that ArrayView does not implement any form of caching - repeat accesses of the same element will re-deserialize the element upon every access.\n\n\n\n\n\n","category":"type"},{"location":"#MsgPack.MapView","page":"API Documentation","title":"MsgPack.MapView","text":"MapView{K,V} <: AbstractDict{K,V}\n\nSimilar to ArrayView, but provides an immutable view to a MessagePack Map rather than a MessagePack Array.\n\nThis type is intended to be utilized via unpack in the same manner as ArrayView, and is similarly implements a \"delay-deserialization-until-access\" mechanism.\n\n\n\n\n\n","category":"type"},{"location":"#MessagePack-Extension-Functionality-1","page":"API Documentation","title":"MessagePack Extension Functionality","text":"","category":"section"},{"location":"#","page":"API Documentation","title":"API Documentation","text":"MsgPack.Extension\nMsgPack.extserialize\nMsgPack.extdeserialize","category":"page"},{"location":"#MsgPack.Extension","page":"API Documentation","title":"MsgPack.Extension","text":"struct Extension\n    type::Int8\n    data::Vector{UInt8}\nend\n\nA wrapper for bytes formatted to the MessagePack Extension type specification.\n\nSee also: extserialize, extdeserialize\n\n\n\n\n\n","category":"type"},{"location":"#MsgPack.extserialize","page":"API Documentation","title":"MsgPack.extserialize","text":"extserialize(type, x)\n\nReturn Extension(type, data) where data is the result of calling Julia's built-in serialize function on x, facilitating direct serialization Julia values to MessagePack format:\n\njulia> struct Point{T}\n           x::T\n           y::T\n       end\n\njulia> val = [Point(rand(), rand()) for _ in 1:100];\n\njulia> bytes = MsgPack.pack(MsgPack.extserialize(123, x));\n\njulia> type, new_val = MsgPack.extdeserialize(MsgPack.unpack(bytes));\n\njulia> type == 123\ntrue\n\njulia> new_val == val\ntrue\n\nNote that extserialize/extdeserialize are subject to the same caveat as Julia's built-in serialize/deserialize functions: \"In general, this process will not work if the reading and writing are done by different versions of Julia, or an instance of Julia with a different system image.\".\n\nSee also: Extension, extdeserialize\n\n\n\n\n\n","category":"function"},{"location":"#MsgPack.extdeserialize","page":"API Documentation","title":"MsgPack.extdeserialize","text":"extdeserialize(x::Extension)\n\nReturn (x.type, value) where value is the result of calling Julia's built-in deserialize function on x.data.\n\nThis function is meant to be used in conjuction with extserialize; see that function's docstring for more details.\n\nSee also: Extension, extserialize\n\n\n\n\n\n","category":"function"}]
}
